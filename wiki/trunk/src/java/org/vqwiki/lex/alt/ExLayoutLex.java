/* The following code was generated by JFlex 1.3.5 on 6/15/06 12:07 PM */

package org.vqwiki.lex.alt;

/*
Very Quick Wiki - WikiWikiWeb clone
Copyright (C) 2001-2003 Gareth Cronin

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this program (gpl.txt); if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/

import java.io.*;
import org.vqwiki.lex.Lexer;


/**
 * This class is a scanner generated by
 * <a href="http://www.jflex.de/">JFlex</a> 1.3.5
 * on 6/15/06 12:07 PM from the specification file
 * <tt>file:/E:/code/workspace/vqwiki/branches/ryan/vqwiki/src/lex/alt/exlayout.jflex</tt>
 */
public class ExLayoutLex implements org.vqwiki.lex.Lexer {

  /** This character denotes the end of file */
  final public static int YYEOF = -1;

  /** initial size of the lookahead buffer */
  final private static int YY_BUFFERSIZE = 16384;

  /** lexical states */
  final public static int LIST = 8;
  final public static int MULTITABLE = 12;
  final public static int YYINITIAL = 0;
  final public static int EXTERNAL = 14;
  final public static int PRE = 6;
  final public static int TABLE = 10;
  final public static int OFF = 4;
  final public static int NORMAL = 2;

  /**
   * YY_LEXSTATE[l] is the state in the DFA for the lexical state l
   * YY_LEXSTATE[l+1] is the state in the DFA for the lexical state l
   *				  at the beginning of a line
   * l is of the form l = 2*k, k a non negative integer
   */
  private final static int YY_LEXSTATE[] = {
	 0,  0,  1,  2,  3,  3,  4,  4,  5,  6,  7,  8,  0,  9, 10, 10
  };

  /**
   * Translates characters to character classes
   */
  final private static String yycmap_packed =
	"\11\0\1\3\1\1\2\0\1\2\22\0\1\3\1\7\1\0\1\17"+
	"\6\0\1\17\2\0\1\4\1\0\1\15\14\0\1\11\1\0\1\13"+
	"\1\0\1\20\32\12\1\10\1\16\1\14\1\0\1\5\1\0\32\12"+
	"\1\0\1\6\55\0\1\12\12\0\1\12\4\0\1\12\5\0\27\12"+
	"\1\0\37\12\1\0\u013f\12\31\0\162\12\4\0\14\12\16\0\5\12"+
	"\11\0\1\12\213\0\1\12\13\0\1\12\1\0\3\12\1\0\1\12"+
	"\1\0\24\12\1\0\54\12\1\0\46\12\1\0\5\12\4\0\202\12"+
	"\10\0\105\12\1\0\46\12\2\0\2\12\6\0\20\12\41\0\46\12"+
	"\2\0\1\12\7\0\47\12\110\0\33\12\5\0\3\12\56\0\32\12"+
	"\5\0\13\12\43\0\2\12\1\0\143\12\1\0\1\12\17\0\2\12"+
	"\7\0\2\12\12\0\3\12\2\0\1\12\20\0\1\12\1\0\36\12"+
	"\35\0\3\12\60\0\46\12\13\0\1\12\u0152\0\66\12\3\0\1\12"+
	"\22\0\1\12\7\0\12\12\43\0\10\12\2\0\2\12\2\0\26\12"+
	"\1\0\7\12\1\0\1\12\3\0\4\12\3\0\1\12\36\0\2\12"+
	"\1\0\3\12\16\0\2\12\23\0\6\12\4\0\2\12\2\0\26\12"+
	"\1\0\7\12\1\0\2\12\1\0\2\12\1\0\2\12\37\0\4\12"+
	"\1\0\1\12\23\0\3\12\20\0\11\12\1\0\3\12\1\0\26\12"+
	"\1\0\7\12\1\0\2\12\1\0\5\12\3\0\1\12\22\0\1\12"+
	"\17\0\2\12\43\0\10\12\2\0\2\12\2\0\26\12\1\0\7\12"+
	"\1\0\2\12\1\0\5\12\3\0\1\12\36\0\2\12\1\0\3\12"+
	"\17\0\1\12\21\0\1\12\1\0\6\12\3\0\3\12\1\0\4\12"+
	"\3\0\2\12\1\0\1\12\1\0\2\12\3\0\2\12\3\0\3\12"+
	"\3\0\10\12\1\0\3\12\113\0\10\12\1\0\3\12\1\0\27\12"+
	"\1\0\12\12\1\0\5\12\46\0\2\12\43\0\10\12\1\0\3\12"+
	"\1\0\27\12\1\0\12\12\1\0\5\12\3\0\1\12\40\0\1\12"+
	"\1\0\2\12\43\0\10\12\1\0\3\12\1\0\27\12\1\0\20\12"+
	"\46\0\2\12\43\0\22\12\3\0\30\12\1\0\11\12\1\0\1\12"+
	"\2\0\7\12\72\0\60\12\1\0\2\12\14\0\7\12\72\0\2\12"+
	"\1\0\1\12\2\0\2\12\1\0\1\12\2\0\1\12\6\0\4\12"+
	"\1\0\7\12\1\0\3\12\1\0\1\12\1\0\1\12\2\0\2\12"+
	"\1\0\4\12\1\0\2\12\11\0\1\12\2\0\5\12\1\0\1\12"+
	"\25\0\2\12\42\0\1\12\77\0\10\12\1\0\42\12\35\0\4\12"+
	"\164\0\42\12\1\0\5\12\1\0\2\12\45\0\6\12\112\0\46\12"+
	"\12\0\51\12\7\0\132\12\5\0\104\12\5\0\122\12\6\0\7\12"+
	"\1\0\77\12\1\0\1\12\1\0\4\12\2\0\7\12\1\0\1\12"+
	"\1\0\4\12\2\0\47\12\1\0\1\12\1\0\4\12\2\0\37\12"+
	"\1\0\1\12\1\0\4\12\2\0\7\12\1\0\1\12\1\0\4\12"+
	"\2\0\7\12\1\0\7\12\1\0\27\12\1\0\37\12\1\0\1\12"+
	"\1\0\4\12\2\0\7\12\1\0\47\12\1\0\23\12\105\0\125\12"+
	"\14\0\u026c\12\2\0\10\12\12\0\32\12\5\0\113\12\25\0\15\12"+
	"\1\0\4\12\16\0\22\12\16\0\22\12\16\0\15\12\1\0\3\12"+
	"\17\0\64\12\43\0\1\12\4\0\1\12\103\0\130\12\10\0\51\12"+
	"\127\0\35\12\63\0\36\12\2\0\5\12\u038b\0\154\12\224\0\234\12"+
	"\4\0\132\12\6\0\26\12\2\0\6\12\2\0\46\12\2\0\6\12"+
	"\2\0\10\12\1\0\1\12\1\0\1\12\1\0\1\12\1\0\37\12"+
	"\2\0\65\12\1\0\7\12\1\0\1\12\3\0\3\12\1\0\7\12"+
	"\3\0\4\12\2\0\6\12\4\0\15\12\5\0\3\12\1\0\7\12"+
	"\164\0\1\12\15\0\1\12\202\0\1\12\4\0\1\12\2\0\12\12"+
	"\1\0\1\12\3\0\5\12\6\0\1\12\1\0\1\12\1\0\1\12"+
	"\1\0\4\12\1\0\3\12\1\0\7\12\3\0\3\12\5\0\5\12"+
	"\u0ebb\0\2\12\52\0\5\12\5\0\2\12\4\0\126\12\6\0\3\12"+
	"\1\0\132\12\1\0\4\12\5\0\50\12\4\0\136\12\21\0\30\12"+
	"\70\0\20\12\u0200\0\u19b6\12\112\0\u51a6\12\132\0\u048d\12\u0773\0\u2ba4\12"+
	"\u215c\0\u012e\12\2\0\73\12\225\0\7\12\14\0\5\12\5\0\1\12"+
	"\1\0\12\12\1\0\15\12\1\0\5\12\1\0\1\12\1\0\2\12"+
	"\1\0\2\12\1\0\154\12\41\0\u016b\12\22\0\100\12\2\0\66\12"+
	"\50\0\14\12\164\0\5\12\1\0\207\12\44\0\32\12\6\0\32\12"+
	"\13\0\131\12\3\0\6\12\2\0\6\12\2\0\6\12\2\0\3\12"+
	"\43\0";

  /**
   * Translates characters to character classes
   */
  final private static char [] yycmap = yy_unpack_cmap(yycmap_packed);

  /**
   * Translates a state to a row index in the transition table
   */
  final private static int yy_rowMap [] = {
		0,	17,	34,	51,	68,	85,   102,   119,   136,   153,
	  170,	 0,	 0,   187,	 0,   204,   221,   238,   255,   272,
	  289,   306,   323,   340,   357,   374,   391,	 0,	 0,   408,
	  425,	 0,   442,	 0,   459,   476,   493,	 0,   510,   527,
	  544,   340,   561,   578,   595,	 0,	 0,   612,   374,   629,
	  646,	 0,   663,   680,   697,   714,   731,	 0,   748,	 0,
	  765,	 0,   782,	 0,	 0,   799,	 0,   816,   663,   680,
		0,   833,   850,   867,   884,   901,   918,   935,   952,	 0,
	  969,	 0,	 0,   986,	 0,  1003,	 0,  1020,	 0,  1037,
	 1054,	 0
  };

  /**
   * The packed transition table of the DFA (part 0)
   */
  final private static String yy_packed0 =
	"\21\0\1\14\1\15\1\16\1\17\1\20\1\21\2\14"+
	"\1\22\5\14\1\23\1\14\1\24\1\14\1\25\1\26"+
	"\1\17\1\20\1\21\1\27\1\14\1\22\5\14\1\23"+
	"\1\30\1\24\1\14\1\15\1\16\1\17\1\14\1\31"+
	"\14\14\1\32\1\33\1\34\1\14\1\21\2\14\1\22"+
	"\5\14\1\23\3\14\1\35\1\36\1\17\16\14\1\35"+
	"\1\36\1\17\13\14\1\37\2\14\3\17\15\14\6\40"+
	"\1\41\12\40\6\42\1\43\12\42\1\14\3\34\4\14"+
	"\1\44\10\14\1\0\1\15\23\0\1\45\21\0\1\46"+
	"\24\0\1\47\14\0\1\50\33\0\1\51\17\0\1\52"+
	"\2\0\1\25\25\0\1\53\1\54\11\0\1\55\1\0"+
	"\17\55\5\0\1\56\14\0\1\57\1\60\17\0\1\61"+
	"\20\0\1\35\17\0\1\62\1\0\17\62\6\0\1\63"+
	"\12\0\4\64\1\65\1\64\1\66\12\64\11\0\1\67"+
	"\13\0\1\70\26\0\1\71\13\0\1\72\33\0\1\73"+
	"\1\53\1\74\4\53\1\75\12\53\1\54\1\76\4\54"+
	"\1\77\12\54\1\55\1\100\17\55\1\0\1\57\17\0"+
	"\1\62\1\101\17\62\1\63\1\0\4\63\1\102\12\63"+
	"\1\0\1\103\1\104\1\105\15\0\1\106\1\107\17\106"+
	"\15\0\1\110\7\0\1\111\26\0\1\71\1\112\25\0"+
	"\1\113\1\53\1\74\4\53\1\114\12\53\1\54\1\76"+
	"\4\54\1\115\12\54\1\63\1\0\4\63\1\116\12\63"+
	"\1\0\1\103\31\0\1\117\7\0\1\120\1\121\32\0"+
	"\1\122\5\0\1\123\1\124\16\0\1\53\1\125\1\126"+
	"\3\53\1\114\12\53\1\54\1\127\1\130\3\54\1\115"+
	"\12\54\1\63\1\131\1\132\3\63\1\116\12\63\12\0"+
	"\1\117\1\133\6\0\1\120\20\0\1\123\17\0\1\53"+
	"\1\125\4\53\1\75\12\53\1\54\1\127\4\54\1\77"+
	"\12\54\1\63\1\131\4\63\1\102\12\63\14\0\1\134"+
	"\4\0";

  /**
   * The transition table of the DFA
   */
  final private static int yytrans [] = yy_unpack();


  /* error codes */
  final private static int YY_UNKNOWN_ERROR = 0;
  final private static int YY_ILLEGAL_STATE = 1;
  final private static int YY_NO_MATCH = 2;
  final private static int YY_PUSHBACK_2BIG = 3;

  /* error messages for the codes above */
  final private static String YY_ERROR_MSG[] = {
	"Unkown internal scanner error",
	"Internal error: unknown state",
	"Error: could not match input",
	"Error: pushback value was too large"
  };

  /**
   * YY_ATTRIBUTE[aState] contains the attributes of state <code>aState</code>
   */
  private final static byte YY_ATTRIBUTE[] = {
	 8,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  9,  9,  1,  9,  1,
	 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  9,  9,  1,  1,  9,
	 1,  9,  0,  1,  0,  9,  0,  0,  0,  0,  0,  0,  0,  9,  9,  0,
	 0,  0,  0,  9,  1,  1,  0,  0,  0,  9,  0,  9,  0,  9,  0,  9,
	 9,  0,  9,  0,  0,  0,  9,  0,  0,  0,  0,  0,  0,  0,  0,  9,
	 0,  9,  9,  0,  9,  0,  9,  0,  9,  0,  0,  9
  };

  /** the input device */
  private java.io.Reader yy_reader;

  /** the current state of the DFA */
  private int yy_state;

  /** the current lexical state */
  private int yy_lexical_state = YYINITIAL;

  /** this buffer contains the current text to be matched and is
	  the source of the yytext() string */
  private char yy_buffer[] = new char[YY_BUFFERSIZE];

  /** the textposition at the last accepting state */
  private int yy_markedPos;

  /** the textposition at the last state to be included in yytext */
  private int yy_pushbackPos;

  /** the current text position in the buffer */
  private int yy_currentPos;

  /** startRead marks the beginning of the yytext() string in the buffer */
  private int yy_startRead;

  /** endRead marks the last character in the buffer, that has been read
	  from input */
  private int yy_endRead;

  /** number of newlines encountered up to the start of the matched text */
  private int yyline;

  /** the number of characters up to the start of the matched text */
  private int yychar;

  /**
   * the number of characters from the last newline up to the start of the
   * matched text
   */
  private int yycolumn;

  /**
   * yy_atBOL == true <=> the scanner is currently at the beginning of a line
   */
  private boolean yy_atBOL = true;

  /** yy_atEOF == true <=> the scanner is at the EOF */
  private boolean yy_atEOF;

  /* user code: */

	ExLayoutLexConvert convert = new ExLayoutLexConvert();

  	public void setVirtualWiki( String vWiki ){
		convert.setVirtualWiki(vWiki);
  	}



  /**
   * Creates a new scanner
   * There is also a java.io.InputStream version of this constructor.
   *
   * @param   in  the java.io.Reader to read input from.
   */
  public ExLayoutLex(java.io.Reader in) {
  	yybegin( NORMAL );
	this.yy_reader = in;
  }

  /**
   * Creates a new scanner.
   * There is also java.io.Reader version of this constructor.
   *
   * @param   in  the java.io.Inputstream to read input from.
   */
  public ExLayoutLex(java.io.InputStream in) {
	this(new java.io.InputStreamReader(in));
  }

  /**
   * Unpacks the split, compressed DFA transition table.
   *
   * @return the unpacked transition table
   */
  private static int [] yy_unpack() {
	int [] trans = new int[1071];
	int offset = 0;
	offset = yy_unpack(yy_packed0, offset, trans);
	return trans;
  }

  /**
   * Unpacks the compressed DFA transition table.
   *
   * @param packed   the packed transition table
   * @return		 the index of the last entry
   */
  private static int yy_unpack(String packed, int offset, int [] trans) {
	int i = 0;	   /* index in packed string  */
	int j = offset;  /* index in unpacked array */
	int l = packed.length();
	while (i < l) {
	  int count = packed.charAt(i++);
	  int value = packed.charAt(i++);
	  value--;
	  do trans[j++] = value; while (--count > 0);
	}
	return j;
  }

  /**
   * Unpacks the compressed character translation table.
   *
   * @param packed   the packed character translation table
   * @return		 the unpacked character translation table
   */
  private static char [] yy_unpack_cmap(String packed) {
	char [] map = new char[0x10000];
	int i = 0;  /* index in packed string  */
	int j = 0;  /* index in unpacked array */
	while (i < 1162) {
	  int  count = packed.charAt(i++);
	  char value = packed.charAt(i++);
	  do map[j++] = value; while (--count > 0);
	}
	return map;
  }


  /**
   * Refills the input buffer.
   *
   * @return	  <code>false</code>, iff there was new input.
   *
   * @exception   IOException  if any I/O-Error occurs
   */
  private boolean yy_refill() throws java.io.IOException {

	/* first: make room (if you can) */
	if (yy_startRead > 0) {
	  System.arraycopy(yy_buffer, yy_startRead,
					   yy_buffer, 0,
					   yy_endRead-yy_startRead);

	  /* translate stored positions */
	  yy_endRead-= yy_startRead;
	  yy_currentPos-= yy_startRead;
	  yy_markedPos-= yy_startRead;
	  yy_pushbackPos-= yy_startRead;
	  yy_startRead = 0;
	}

	/* is the buffer big enough? */
	if (yy_currentPos >= yy_buffer.length) {
	  /* if not: blow it up */
	  char newBuffer[] = new char[yy_currentPos*2];
	  System.arraycopy(yy_buffer, 0, newBuffer, 0, yy_buffer.length);
	  yy_buffer = newBuffer;
	}

	/* finally: fill the buffer with new input */
	int numRead = yy_reader.read(yy_buffer, yy_endRead,
											yy_buffer.length-yy_endRead);

	if (numRead < 0) {
	  return true;
	}
	else {
	  yy_endRead+= numRead;
	  return false;
	}
  }


  /**
   * Closes the input stream.
   */
  final public void yyclose() throws java.io.IOException {
	yy_atEOF = true;			/* indicate end of file */
	yy_endRead = yy_startRead;  /* invalidate buffer	*/

	if (yy_reader != null)
	  yy_reader.close();
  }


  /**
   * Closes the current stream, and resets the
   * scanner to read from a new input stream.
   *
   * All internal variables are reset, the old input stream
   * <b>cannot</b> be reused (internal buffer is discarded and lost).
   * Lexical state is set to <tt>YY_INITIAL</tt>.
   *
   * @param reader   the new input stream
   */
  final public void yyreset(java.io.Reader reader) throws java.io.IOException {
	yyclose();
	yy_reader = reader;
	yy_atBOL  = true;
	yy_atEOF  = false;
	yy_endRead = yy_startRead = 0;
	yy_currentPos = yy_markedPos = yy_pushbackPos = 0;
	yyline = yychar = yycolumn = 0;
	yy_lexical_state = YYINITIAL;
  }


  /**
   * Returns the current lexical state.
   */
  final public int yystate() {
	return yy_lexical_state;
  }


  /**
   * Enters a new lexical state
   *
   * @param newState the new lexical state
   */
  final public void yybegin(int newState) {
	yy_lexical_state = newState;
  }


  /**
   * Returns the text matched by the current regular expression.
   */
  final public String yytext() {
	return new String( yy_buffer, yy_startRead, yy_markedPos-yy_startRead );
  }


  /**
   * Returns the character at position <tt>pos</tt> from the
   * matched text.
   *
   * It is equivalent to yytext().charAt(pos), but faster
   *
   * @param pos the position of the character to fetch.
   *			A value from 0 to yylength()-1.
   *
   * @return the character at position pos
   */
  final public char yycharat(int pos) {
	return yy_buffer[yy_startRead+pos];
  }


  /**
   * Returns the length of the matched text region.
   */
  final public int yylength() {
	return yy_markedPos-yy_startRead;
  }


  /**
   * Reports an error that occured while scanning.
   *
   * In a wellformed scanner (no or only correct usage of
   * yypushback(int) and a match-all fallback rule) this method
   * will only be called with things that "Can't Possibly Happen".
   * If this method is called, something is seriously wrong
   * (e.g. a JFlex bug producing a faulty scanner etc.).
   *
   * Usual syntax/scanner level error handling should be done
   * in error fallback rules.
   *
   * @param   errorCode  the code of the errormessage to display
   */
  private void yy_ScanError(int errorCode) {
	String message;
	try {
	  message = YY_ERROR_MSG[errorCode];
	}
	catch (ArrayIndexOutOfBoundsException e) {
	  message = YY_ERROR_MSG[YY_UNKNOWN_ERROR];
	}

	throw new Error(message);
  }


  /**
   * Pushes the specified amount of characters back into the input stream.
   *
   * They will be read again by then next call of the scanning method
   *
   * @param number  the number of characters to be read again.
   *				This number must not be greater than yylength()!
   */
  private void yypushback(int number)  {
	if ( number > yylength() )
	  yy_ScanError(YY_PUSHBACK_2BIG);

	yy_markedPos -= number;
  }


  /**
   * Resumes scanning until the next regular expression is matched,
   * the end of input is encountered or an I/O-Error occurs.
   *
   * @return	  the next token
   * @exception   IOException  if any I/O-Error occurs
   */
  public String yylex() throws java.io.IOException {
	int yy_input;
	int yy_action;

	// cached fields:
	int yy_currentPos_l;
	int yy_startRead_l;
	int yy_markedPos_l;
	int yy_endRead_l = yy_endRead;
	char [] yy_buffer_l = yy_buffer;
	char [] yycmap_l = yycmap;

	int [] yytrans_l = yytrans;
	int [] yy_rowMap_l = yy_rowMap;
	byte [] yy_attr_l = YY_ATTRIBUTE;

	while (true) {
	  yy_markedPos_l = yy_markedPos;

	  if (yy_markedPos_l > yy_startRead) {
		switch (yy_buffer_l[yy_markedPos_l-1]) {
		case '\n':
		case '\u000B':
		case '\u000C':
		case '\u0085':
		case '\u2028':
		case '\u2029':
		  yy_atBOL = true;
		  break;
		case '\r':
		  if (yy_markedPos_l < yy_endRead_l)
			yy_atBOL = yy_buffer_l[yy_markedPos_l] != '\n';
		  else if (yy_atEOF)
			yy_atBOL = false;
		  else {
			boolean eof = yy_refill();
			yy_markedPos_l = yy_markedPos;
			yy_buffer_l = yy_buffer;
			if (eof)
			  yy_atBOL = false;
			else
			  yy_atBOL = yy_buffer_l[yy_markedPos_l] != '\n';
		  }
		  break;
		default:
		  yy_atBOL = false;
		}
	  }
	  yy_action = -1;

	  yy_startRead_l = yy_currentPos_l = yy_currentPos =
					   yy_startRead = yy_markedPos_l;

	  if (yy_atBOL)
		yy_state = YY_LEXSTATE[yy_lexical_state+1];
	  else
		yy_state = YY_LEXSTATE[yy_lexical_state];


	  yy_forAction: {
		while (true) {

		  if (yy_currentPos_l < yy_endRead_l)
			yy_input = yy_buffer_l[yy_currentPos_l++];
		  else if (yy_atEOF) {
			yy_input = YYEOF;
			break yy_forAction;
		  }
		  else {
			// store back cached positions
			yy_currentPos  = yy_currentPos_l;
			yy_markedPos   = yy_markedPos_l;
			boolean eof = yy_refill();
			// get translated positions and possibly new buffer
			yy_currentPos_l  = yy_currentPos;
			yy_markedPos_l   = yy_markedPos;
			yy_buffer_l	  = yy_buffer;
			yy_endRead_l	 = yy_endRead;
			if (eof) {
			  yy_input = YYEOF;
			  break yy_forAction;
			}
			else {
			  yy_input = yy_buffer_l[yy_currentPos_l++];
			}
		  }
		  int yy_next = yytrans_l[ yy_rowMap_l[yy_state] + yycmap_l[yy_input] ];
		  if (yy_next == -1) break yy_forAction;
		  yy_state = yy_next;

		  int yy_attributes = yy_attr_l[yy_state];
		  if ( (yy_attributes & 1) == 1 ) {
			yy_action = yy_state;
			yy_markedPos_l = yy_currentPos_l;
			if ( (yy_attributes & 8) == 8 ) break yy_forAction;
		  }

		}
	  }

	  // store back cached position
	  yy_markedPos = yy_markedPos_l;

	  switch (yy_action) {

		case 82:
		  {
  yybegin( PRE );
  return convert.onPreFormatBegin();
 }
		case 93: break;
		case 31:
		  {
  yypushback(1);
  yybegin( NORMAL );
  return convert.onTableEnd();
 }
		case 94: break;
		case 57:
		  {
  return "\\__";
 }
		case 95: break;
		case 63:
		  {
  // since the originalauthor removes \n after headers,
  // we can't indicate at the beginning of the line.
  // so we need to change headers also with \r at the end.
  yybegin( LIST );
  return convert.onListBegin(yytext());
 }
		case 96: break;
		case 64:
		  {
  return convert.onListLine(yytext());
 }
		case 97: break;
		case 11:
		case 15:
		case 16:
		case 17:
		case 18:
		case 19:
		case 22:
		case 23:
		case 24:
		case 30:
		case 32:
		case 35:
		  {
  return yytext();
 }
		case 98: break;
		case 13:
		case 14:
		case 21:
		case 29:
		  {
  return convert.onRemoveWhitespace(yytext());
 }
		case 99: break;
		case 70:
		  {
  return convert.onMultiTableCell(yytext());
 }
		case 100: break;
		case 86:
		  {
  yybegin( TABLE );
  return convert.onTableStartWithHeader(yytext());
 }
		case 101: break;
		case 12:
		case 20:
		  {
  return convert.onNewLine();
 }
		case 102: break;
		case 46:
		  {
  yybegin( NORMAL );
  return convert.onPreFormatEnd();
 }
		case 103: break;
		case 61:
		  {
  yybegin( MULTITABLE );
  return convert.onMultiTableStartWithHeader(yytext());
 }
		case 104: break;
		case 25:
		case 26:
		case 27:
		  {
  return convert.onKeepWhitespace(yytext());
 }
		case 105: break;
		case 79:
		  {
  return convert.onHorizontalRuler();
 }
		case 106: break;
		case 66:
		  {
  return convert.onMultiTableRow(yytext());
 }
		case 107: break;
		case 91:
		  {
  yybegin( NORMAL );
  return yytext();
 }
		case 108: break;
		case 81:
		  {
  yybegin( EXTERNAL );
  return yytext();
 }
		case 109: break;
		case 37:
		  {
  yybegin( OFF );
  return "__";
 }
		case 110: break;
		case 33:
		  {
  yypushback(1);
  yybegin( NORMAL );
  return convert.onMultiTableEnd();
 }
		case 111: break;
		case 51:
		case 52:
		  {
  yypushback(2);
  yybegin( NORMAL );
  return convert.onMultiTableEnd();
 }
		case 112: break;
		case 53:
		  {
  yypushback(2);
  yybegin( NORMAL );
  return convert.onMultiTableEnd();
 }
		case 113: break;
		case 28:
		  {
  yybegin( NORMAL );
  return convert.onListEnd();
 }
		case 114: break;
		case 84:
		  {
  yybegin( TABLE );
  return convert.onTableStart(yytext());
 }
		case 115: break;
		case 59:
		  {
  yybegin( MULTITABLE );
  return convert.onMultiTableStart(yytext());
 }
		case 116: break;
		case 45:
		  {
  yybegin( NORMAL );
  return "__";
 }
		case 117: break;
		case 88:
		  {
  return convert.onTableCell(yytext());
 }
		case 118: break;
		default:
		  if (yy_input == YYEOF && yy_startRead == yy_currentPos) {
			yy_atEOF = true;
			  {	 if( yy_lexical_state == LIST ){
	  yybegin( NORMAL );
	  return convert.onListEOF();
	}
	if( yy_lexical_state == TABLE ){
	  yybegin( NORMAL );
	  return convert.onTableEOF();
	}
	if( yy_lexical_state == MULTITABLE)
	{
	  yybegin( NORMAL );
	  return convert.onMultiTableEOF();
	}

	return null;
 }
		  }
		  else {
			yy_ScanError(YY_NO_MATCH);
		  }
	  }
	}
  }


}
