package org.jmwiki.parser.alt;import java.io.BufferedReader;import java.io.InputStream;import java.io.InputStreamReader;import java.io.IOException;import java.io.Reader;import java.io.StringReader;import java.util.ArrayList;import java.util.List;import org.apache.log4j.Logger;import org.jmwiki.Environment;import org.jmwiki.parser.AbstractParser;import org.jmwiki.parser.Lexer;import org.jmwiki.parser.ParserInfo;import org.jmwiki.parser.TableOfContents;/** * * Default lexer implementation for VQWiki. * */public class VQWikiParser extends AbstractParser {	private static final Logger logger = Logger.getLogger(VQWikiParser.class);	private static final String PARSER_BUNDLE = "defaultParser";	private static final String PARSER_VERSION = "2.7.8";	private static final String PARSER_NAME = "Default Parser";	private static List wikinameIgnore;	/**	 *	 */	public VQWikiParser() {		super(new ParserInfo(PARSER_NAME, PARSER_VERSION, PARSER_BUNDLE));	}	/**	 *	 */	protected VQWikiParser(ParserInfo parserInfo) {		super(parserInfo);	}	/**	 * This method looks for a properties file named wikinames.ignore and	 * then checks a name passed to this method against the list of names (if	 * any) in that file.  If the name is found return true, otherwise return	 * false;	 *	 * @param name The name of the topic to check for in the ignore file.	 * @return Returns <code>true</code> if the name is found in the ignore file,	 *  otherwise returns <code>false</code>.	 */	public static boolean doIgnoreWikiname(String name) {		if (wikinameIgnore == null) {			wikinameIgnore = new ArrayList();			// FIXME - "VQWikiParser.class" may not work in a static method			InputStream in = VQWikiParser.class.getResourceAsStream("/wikiname.ignore");			if (in == null) {				logger.debug("No wikinames to ignore, wikiname.ignore does not exist");				return false;			}			try {				BufferedReader reader = new BufferedReader(new InputStreamReader(in));				while (true) {					String line = reader.readLine();					if (line == null) {						break;					}					logger.debug("Adding " + line.toLowerCase() + " to ignore list");					wikinameIgnore.add(line.toLowerCase());				}				reader.close();				in.close();			} catch (IOException e) {				logger.warn("Error reading wikiname.ignore", e);			}		}		if (wikinameIgnore.isEmpty()) {			return false;		}		boolean ignore = wikinameIgnore.contains(name.toLowerCase());		if (ignore) {			logger.debug("Do ignore " + name);		}		return ignore;	}	/**	 *	 * Parse text for online display.	 *	 */	public String parseHTML(String context, String virtualwiki, String rawtext) throws IOException {		StringBuffer contents = new StringBuffer();		Reader raw = new StringReader(rawtext.toString());		contents = this.parseFormat(raw, virtualwiki);		raw = new StringReader(contents.toString());		contents = this.parseLayout(raw, virtualwiki);		raw = new StringReader(contents.toString());		contents = this.parseLinks(raw, virtualwiki);		// remove trailing returns at the end of the site.		return this.removeTrailingNewlines(contents.toString());	}	/**	 *	 *	 *	 */	private StringBuffer parseFormat(Reader raw, String virtualWiki) throws IOException {		StringBuffer contents = new StringBuffer();		VQWikiFormatLex lexer = new VQWikiFormatLex(raw);		lexer.setVirtualWiki(virtualWiki);		boolean external = false;		String tag = null;		StringBuffer externalContents = null;		while (true) {			String line = null;			try {				line = lexer.yylex();			} catch (ArrayIndexOutOfBoundsException e) {				logger.debug(e);			}			logger.debug(line);			if (line == null) {				break;			}			if (line.startsWith("[<")) {				if (!external) {					external = true;					tag = line.substring(2, line.length() - 2);					logger.debug("External lex call (tag=" + tag + ")");					externalContents = new StringBuffer();					contents.append(line);				} else {					external = false;					String converted = LexExtender.getInstance().lexify(					tag,					externalContents.toString()					);					if (converted != null) {						contents.append(converted);					}					contents.append(line);					logger.debug("External ends");				}			} else {				if (!external) {					contents.append(line);				} else {					externalContents.append(line);				}			}		}		if (Environment.getBooleanValue(Environment.PROP_PARSER_TOC)) {			contents = new StringBuffer(TableOfContents					.addTableOfContents(contents.toString()));		}		return contents;	}	/**	 *	 *	 *	 */	private StringBuffer parseLayout(Reader raw, String virtualWiki) throws IOException {		VQWikiLayoutLex lexer = new VQWikiLayoutLex(raw);		lexer.setVirtualWiki(virtualWiki);		return this.lex(lexer);	}	/**	 *	 *	 *	 */	private StringBuffer parseLinks(Reader raw, String virtualWiki) throws IOException {		VQWikiLinkLex lexer = new VQWikiLinkLex(raw);		lexer.setVirtualWiki(virtualWiki);		return this.lex(lexer);	}	/**	 *	 *	 *	 */	private StringBuffer parseExportLinks(Reader raw, String virtualWiki) throws IOException {		HTMLLinkLex lexer = new HTMLLinkLex(raw);		lexer.setVirtualWiki(virtualWiki);		return this.lex(lexer);	}	/**	 *	 *	 *	 */	private String removeTrailingNewlines(String content) {		// remove trailing returns at the end of the site.		// TODO better do this with StringBuffer, but actually no more		// time for a proper cleanup.		if (content.endsWith("<br/>\n")) {			content = content.substring(0, content.length() - 6);			while (content.endsWith("<br/>")) {				content = content.substring(0, content.length() - 5);			}		}		return content;	}	/**	 * Utility method for executing a lexer parse.	 * FIXME - this is copy & pasted here and in MediaWikiParser	 */	protected StringBuffer lex(Lexer lexer) throws IOException {		StringBuffer contents = new StringBuffer();		while (true) {			String line = lexer.yylex();			if (line == null) {				break;			}			contents.append(line);		}		return contents;	}}